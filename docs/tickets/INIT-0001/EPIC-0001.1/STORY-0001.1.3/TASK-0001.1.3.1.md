# TASK-0001.1.3.1: Create Typer App with Dual Output Modes

**Parent Story**: [STORY-0001.1.3](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 3
**Actual Hours**: -

## Objective

Create typer CLI application optimized for Claude Code invocation with dual output modes (rich for human presentation, JSON for programmatic parsing).

## Implementation Checklist

### Phase 1: Typer App Foundation (TDD - Write Tests First)

- [ ] Write unit test for typer app initialization (`tests/unit/cli/test_app.py`)
  - Assert: `assert app.app is not None and isinstance(app.app, typer.Typer)`
  - Assert: `assert callable(app.app)`
- [ ] Write unit test for --version flag
  - Assert: `assert result.exit_code == 0`
  - Assert: `assert "gitstory" in result.output and version_string in result.output`
- [ ] Write unit test for --help flag
  - Assert: `assert result.exit_code == 0`
  - Assert: `assert "Usage:" in result.output`
  - Assert: `assert "--json" in result.output and "--version" in result.output`
- [ ] Write unit test for --json global flag
  - Assert: `assert app.json_mode is True when --json provided`
  - Assert: `assert app.json_mode is False by default`
- [ ] Run tests: `pytest tests/unit/cli/test_app.py -v` - all fail âœ“
- [ ] Target coverage: >90% for Phase 1 code

### Phase 2: Implementation (GREEN)

- [ ] Create `src/gitstory/cli/__init__.py` with typer.Typer() app
  - Import: `import typer` and `from importlib.metadata import version, PackageNotFoundError`
  - Initialize: `app = typer.Typer(rich_markup_mode="rich", add_completion=False)`
  - Global flag: `json_mode: bool = typer.Option(False, "--json", help="Output JSON for programmatic parsing")`
- [ ] Add `--json` global flag using typer.Option()
  - Store in app context: `ctx.obj = {"json_mode": json_mode}`
- [ ] Implement version callback reading from `importlib.metadata.version("gitstory")`
  - Error handling: If PackageNotFoundError raised, return "0.0.0-dev" with console warning
  - Format: `gitstory version {version_string}`
- [ ] Create `src/gitstory/__main__.py` entry point that calls `cli.app()`
  - Import: `from gitstory.cli import app`
  - Entry: `if __name__ == "__main__": app()`
- [ ] Run tests: `pytest tests/unit/cli/test_app.py -v` - all pass âœ“

### Phase 3: Output Infrastructure

- [ ] Create `src/gitstory/cli/output.py` with OutputFormatter class
  - Import: `from typing import Dict, Any`, `import json`, `from rich.console import Console`
  - Method signature: `def __init__(self, json_mode: bool = False) -> None:`
- [ ] Implement `render_rich(data)` method using rich.console.Console
  - Signature: `def render_rich(self, data: Dict[str, Any]) -> str:`
  - Uses: `Console().print()` with ANSI color codes via `rich.style.Style`
  - Returns: Formatted string with ANSI escape sequences
- [ ] Implement `render_json(data)` method using json.dumps with indent=2
  - Signature: `def render_json(self, data: Dict[str, Any]) -> str:`
  - Implementation: `return json.dumps(data, indent=2, ensure_ascii=False)`
- [ ] Write unit tests for OutputFormatter (`tests/unit/cli/test_output.py`)
  - Test: JSON mode outputs parseable JSON (validate with `json.loads()`)
  - Test: Rich mode contains ANSI escape codes (check for `\x1b[` sequences)
  - Test: Both modes handle empty dicts and nested data
- [ ] Run tests: `pytest tests/unit/cli/test_output.py -v` - all pass âœ“

### Verification

- [ ] All unit tests pass: `pytest tests/unit/cli/ -v --cov=src/gitstory/cli`
- [ ] `uvx gitstory --help` displays help text with rich formatting
  - Command: `uvx gitstory --help | grep -q "Usage:" && echo "PASS" || echo "FAIL"`
  - Verify: Output contains "Usage:", "--json", "--version", and ANSI color codes
- [ ] `uvx gitstory --version` displays version from pyproject.toml
  - Command: `uvx gitstory --version | grep -q "gitstory version" && echo "PASS" || echo "FAIL"`
  - Verify: Output matches format "gitstory version X.Y.Z"
- [ ] `uvx gitstory --json --help` outputs JSON format
  - Command: `uvx gitstory --json --help | python -m json.tool > /dev/null && echo "PASS" || echo "FAIL"`
  - Verify: Output is valid JSON (parseable by `json.tool`)
- [ ] Entry point callable programmatically: `python -m gitstory --help` works
  - Command: `python -m gitstory --help | grep -q "Usage:" && echo "PASS" || echo "FAIL"`
  - Verify: Same output as `uvx gitstory --help`
- [ ] Code coverage >90% for cli/__init__.py and cli/output.py
  - Command: `pytest tests/unit/cli/ --cov=src/gitstory/cli --cov-report=term-missing`
  - Verify: Coverage report shows >90% for both files

## Files to Create/Modify

- CREATE: `src/gitstory/cli/__init__.py` (50-70 lines, typer app with global flags)
  - Typer app initialization with rich_markup_mode
  - Global --json flag with context storage
  - Version callback with error handling
  - Example: See "Entry Point Pattern" section below
- CREATE: `src/gitstory/cli/output.py` (80-100 lines, OutputFormatter class)
  - OutputFormatter class with dual-mode rendering
  - render_rich() and render_json() methods with type hints
  - Example: See "OutputFormatter API Design" section
- MODIFY: `src/gitstory/__main__.py` (10-15 lines, entry point implementation)
  - Import app from cli module
  - if __name__ == "__main__": app() pattern
- CREATE: `tests/unit/cli/__init__.py` (empty, marks directory as package)
- CREATE: `tests/unit/cli/test_app.py` (60-80 lines, typer app tests)
  - Test app initialization, --version, --help, --json flags
  - Use typer.testing.CliRunner for invocation tests
- CREATE: `tests/unit/cli/test_output.py` (50-70 lines, output formatter tests)
  - Test both render modes with various data structures
  - Validate JSON parseability and rich ANSI codes

## Design Decisions

### Dual Output Philosophy

**Rich output (default):** For human presentation when Claude shows results to users
- Uses rich.console for colors, tables, progress bars
- Visually appealing, easy to read in terminal
- Example: `[green]âœ“[/green] Story created successfully`

**JSON output (--json flag):** For programmatic parsing by Claude
- Structured data Claude can parse and use in logic
- Consistent schema across all commands
- Example: `{"status": "success", "ticket_id": "STORY-0001.2.4", "message": "Story created"}`

### Entry Point Pattern

```python
# src/gitstory/__main__.py
from gitstory.cli import app

if __name__ == "__main__":
    app()
```

This allows both:
- `gitstory` command (via pyproject.toml entry point)
- `python -m gitstory` (direct module invocation)
- `import gitstory.cli; gitstory.cli.app()` (programmatic)

## Pattern Reuse

- `pytest` - Unit testing framework (already configured in STORY-0001.1.1)
- `typer` - CLI framework with built-in testing support
- `rich` - Terminal formatting (already dependency in STORY-0001.1.2)

## Dependencies

- STORY-0001.1.2 complete (CLI package structure exists)
- pyproject.toml dependencies: typer>=0.9, rich>=13.0, pydantic>=2.0

## Success Criteria

- âœ… Typer app initialized and tests pass
- âœ… --version and --help flags work correctly
- âœ… --json flag toggles output mode globally
- âœ… OutputFormatter supports both rich and JSON rendering
- âœ… Entry point works via `uvx`, `pipx`, and `python -m`
- âœ… Code coverage >90%
