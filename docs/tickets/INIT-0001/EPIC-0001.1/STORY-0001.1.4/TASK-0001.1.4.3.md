# TASK-0001.1.4.3: Implement trigger matching and variable substitution

**Parent Story**: [STORY-0001.1.4](README.md)
**Status**: ðŸ”µ Not Started
**Estimated Hours**: 8
**Actual Hours**: -

## Objective

Implement core command processing logic: trigger matching (pattern/keyword/ticket_id) and variable substitution ({ticket_id}, {branch_name}, {user_input}, etc.). Core implementation task with comprehensive TDD coverage.

## BDD Progress

**Before this task**: 2/7 scenarios passing
**After this task**: 5/7 scenarios passing

**Scenarios for this task:**

- Scenario 3: Command triggers support 3 pattern types (FULL - trigger matching)
- Scenario 4: Command variables support substitution patterns (FULL - variable substitution)

## Implementation Checklist

### Unit Tests First (TDD - RED)

#### Trigger Matching Tests

- [ ] Create `tests/unit/commands/test_trigger_matcher.py`
- [ ] Write test for pattern triggers with regex (5+ tests):
  - [ ] Test: `/gitstory:plan STORY-0001.1.2` matches pattern
  - [ ] Test: `/gitstory:review EPIC-0001.1` matches pattern
  - [ ] Test: Invalid format doesn't match
  - [ ] Test: Capture groups extract ticket ID
  - [ ] Test: Multiple patterns OR together
- [ ] Write test for keyword triggers (5+ tests):
  - [ ] Test: "create ticket" matches keyword
  - [ ] Test: Case-insensitive matching ("Create Ticket")
  - [ ] Test: Keyword anywhere in message
  - [ ] Test: Multiple keywords OR together
  - [ ] Test: Exact match vs substring
- [ ] Write test for ticket_id triggers (5+ tests):
  - [ ] Test: "STORY-*" matches STORY-0001.1.2
  - [ ] Test: "EPIC-*" matches EPIC-0001.1
  - [ ] Test: Wildcard patterns work correctly
  - [ ] Test: Invalid IDs don't match
  - [ ] Test: Extract ticket ID from match

#### Variable Substitution Tests

- [ ] Create `tests/unit/commands/test_variable_substitutor.py`
- [ ] Write test for {ticket_id} substitution (2+ tests):
  - [ ] Test: Extract from trigger match
  - [ ] Test: Validate ticket ID format
- [ ] Write test for {branch_name} substitution (2+ tests):
  - [ ] Test: Get from git rev-parse
  - [ ] Test: Handle git errors gracefully
- [ ] Write test for {user_input} substitution (2+ tests):
  - [ ] Test: Extract from conversation context
  - [ ] Test: Handle missing input
- [ ] Write test for {git_output} substitution (2+ tests):
  - [ ] Test: Capture git command output
  - [ ] Test: Handle command errors
- [ ] Write test for template variables (2+ tests):
  - [ ] Test: {template.story_points} references template field
  - [ ] Test: Nested path access

- [ ] Run all tests - all fail âœ“

### Implementation (GREEN)

#### TriggerMatcher Class

- [ ] Create `src/gitstory/commands/trigger_matcher.py`:
  ```python
  import re
  from fnmatch import fnmatch

  class TriggerMatcher:
      """Match user input against command triggers."""

      def __init__(self, triggers: list[Trigger]):
          self.triggers = triggers

      def match(self, user_input: str) -> Optional[dict]:
          """Check if user input matches any trigger.

          Returns:
              dict with 'trigger' and 'captures' if match, None otherwise
          """
          for trigger in self.triggers:
              if trigger.type == "pattern":
                  match = self._match_pattern(trigger, user_input)
              elif trigger.type == "keyword":
                  match = self._match_keyword(trigger, user_input)
              elif trigger.type == "ticket_id":
                  match = self._match_ticket_id(trigger, user_input)
              else:
                  continue

              if match:
                  return {"trigger": trigger, "captures": match}

          return None

      def _match_pattern(self, trigger: Trigger, text: str) -> Optional[dict]:
          """Match regex pattern trigger."""
          pattern = re.compile(trigger.value)
          match = pattern.search(text)
          if match:
              return {
                  "groups": match.groups(),
                  "groupdict": match.groupdict()
              }
          return None

      def _match_keyword(self, trigger: Trigger, text: str) -> Optional[dict]:
          """Match keyword trigger."""
          keyword = trigger.value
          if trigger.case_insensitive:
              text = text.lower()
              keyword = keyword.lower()

          if keyword in text:
              return {"matched_text": keyword}
          return None

      def _match_ticket_id(self, trigger: Trigger, text: str) -> Optional[dict]:
          """Match ticket ID pattern trigger."""
          # Convert glob pattern to regex
          pattern = trigger.value.replace("*", r"[\d\.]+")
          regex = re.compile(pattern)

          match = regex.search(text)
          if match:
              return {"ticket_id": match.group(0)}
          return None
  ```

#### VariableSubstitutor Class

- [ ] Create `src/gitstory/commands/variable_substitutor.py`:
  ```python
  import re
  import subprocess
  from pathlib import Path

  class VariableSubstitutor:
      """Substitute variables in command steps."""

      def __init__(self, variables: list[Variable], context: dict):
          self.variables = {v.name: v for v in variables}
          self.context = context

      def substitute(self, text: str) -> str:
          """Replace {var_name} with values from context."""
          def replace(match):
              var_name = match.group(1)
              if var_name not in self.variables:
                  logging.warning(f"Undefined variable: {var_name}")
                  return match.group(0)  # Leave unchanged

              variable = self.variables[var_name]
              value = self._resolve_variable(variable)
              return str(value) if value is not None else match.group(0)

          return re.sub(r'\{(\w+(?:\.\w+)*)\}', replace, text)

      def _resolve_variable(self, variable: Variable) -> Optional[str]:
          """Resolve variable value from source."""
          if variable.source == "trigger_match":
              return self.context.get("trigger_captures", {}).get(variable.name)

          elif variable.source == "git":
              if variable.command:
                  result = subprocess.run(
                      variable.command,
                      shell=True,
                      capture_output=True,
                      text=True
                  )
                  return result.stdout.strip() if result.returncode == 0 else None

          elif variable.source == "conversation":
              return self.context.get("user_input")

          elif variable.source == "git_command":
              return self.context.get("git_output")

          elif variable.source == "template":
              template = self.context.get("template", {})
              if variable.path:
                  # Navigate nested path: story_points â†’ template['story_points']
                  return self._get_nested(template, variable.path)

          return None

      def _get_nested(self, obj: dict, path: str) -> Optional[Any]:
          """Get nested value from dict using dot notation."""
          keys = path.split('.')
          for key in keys:
              if isinstance(obj, dict) and key in obj:
                  obj = obj[key]
              else:
                  return None
          return obj
  ```
- [ ] Add logging for undefined variables (warnings, not errors)
- [ ] Add circular reference detection
- [ ] Run tests - all pass âœ“

### BDD Implementation (Scenarios 3, 4)

- [ ] Implement step: "Given command configurations with triggers"
- [ ] Implement step: "When evaluating trigger matching"
- [ ] Implement step: "Then pattern triggers match regex"
- [ ] Implement step: "And keyword triggers match literals"
- [ ] Implement step: "And ticket_id triggers match format"
- [ ] Implement step: "And trigger evaluation is case-insensitive for keywords"
- [ ] Implement step: "Given command with variables"
- [ ] Implement step: "When executing command steps"
- [ ] Implement step: "Then {ticket_id} substitutes current ticket ID"
- [ ] Implement step: "And {branch_name} substitutes current git branch"
- [ ] Implement step: "And undefined variables are logged as warnings"
- [ ] Run BDD tests - Scenarios 1-4, 7 pass (5/7 passing) âœ“

### Verification

- [ ] All unit tests pass (25+ tests, >90% coverage)
- [ ] BDD Scenarios 1, 3, 4, 7 passing (4/7 â†’ 5/7 passing)
- [ ] Trigger matching works for all 3 types
- [ ] Variable substitution handles all source types
- [ ] Error handling graceful (undefined vars logged, not raised)

## Files to Create/Modify

- CREATE: `src/gitstory/commands/trigger_matcher.py` (~120 lines, matching logic)
- CREATE: `src/gitstory/commands/variable_substitutor.py` (~150 lines, substitution logic)
- CREATE: `tests/unit/commands/test_trigger_matcher.py` (~200 lines, 15+ tests)
- CREATE: `tests/unit/commands/test_variable_substitutor.py` (~180 lines, 10+ tests)
- MODIFY: `tests/e2e/steps/test_command_configuration.py` (implement steps for Scenarios 3, 4)

## Pattern Reuse

- `Regex pattern matching` (Python stdlib re module) - Pattern trigger matching with capture groups
- `Glob pattern matching` (Python stdlib fnmatch) - Ticket ID wildcard patterns

## Edge Cases Handled

- Invalid regex patterns (compile error caught, logged)
- Case-insensitive keyword matching
- Multiple triggers OR together (any match fires)
- Undefined variables logged as warnings, not errors
- Git command failures (return None, don't crash)
- Circular variable references (detect and raise ValueError)
- Nested template path access (handle missing keys gracefully)

## Performance Targets

- Trigger matching: <5ms per message
- Variable substitution: <10ms per step
- Git command execution: <100ms (acceptable for external call)
